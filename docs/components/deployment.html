<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta content="width=device-width, initial-scale=1.0" name="viewport">
  <title>OnTrack</title>
  <meta content="" name="description">
  <meta content="" name="keywords">
  <!-- Favicons -->
  <link href="../assets/img/icons8-bus-50 (1).png" rel="icon">
  <link href="../assets/img/apple-touch-icon.png" rel="apple-touch-icon">
  <!-- Google Fonts -->
  <link
    href="https://fonts.googleapis.com/css?family=Open+Sans:300,300i,400,400i,600,600i,700,700i|Raleway:300,300i,400,400i,500,500i,600,600i,700,700i|Poppins:300,300i,400,400i,500,500i,600,600i,700,700i"
    rel="stylesheet">
  <!-- Vendor CSS Files -->
  <link href="../assets/vendor/aos/aos.css" rel="stylesheet">
  <link href="../assets/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">
  <link href="../assets/vendor/bootstrap-icons/bootstrap-icons.css" rel="stylesheet">
  <link href="../assets/vendor/boxicons/css/boxicons.min.css" rel="stylesheet">
  <link href="../assets/vendor/glightbox/css/glightbox.min.css" rel="stylesheet">
  <link href="../assets/vendor/swiper/swiper-bundle.min.css" rel="stylesheet">
  <!-- Template Main CSS File -->
  <link href="../assets/css/style.css" rel="stylesheet">

  <!-- =======================================================
  * Template Name: iPortfolio - v3.1.0
  * Template URL: https://bootstrapmade.com/iportfolio-bootstrap-portfolio-websites-template/
  * Author: BootstrapMade.com
  * License: https://bootstrapmade.com/license/
  ======================================================== -->
</head>

<body>

  <!-- ======= Mobile nav toggle button ======= -->
  <i class="bi bi-list mobile-nav-toggle d-xl-none"></i>

  <!-- ======= Header ======= -->
  <header id="header">
    <div class="d-flex flex-column">

      <div class="profile">
        <img src="../assets/img/icons8-bus-50 (1).png">
        <h1 class="text-light"><a href="index.html"><i>OnTrack</i></a></h1>
      </div>

      <nav id="navbar" class="nav-menu navbar">
        <ul>
          <li><a href="../index.html#hero" class="nav-link scrollto active"><i class="bx bx-home"></i>
              <span>Início</span></a></li>
          <li><a href="../index.html#services" class="nav-link scrollto"><i class="bx bx-file-blank"></i>
              <span>Documentação</span></a></li>
          <li><a href="../index.html#milestones" class="nav-link scrollto"><i class="bx bx-calendar"></i>
              <span>Milestones</span></a></li>
          <li><a href="../index.html#team" class="nav-link scrollto"><i class="bx bx-user"></i> <span>Equipa</span></a>
          </li>
        </ul>
      </nav>

    </div>
  </header>
  <!-- End Header -->

  <!-- ======= Main Section ======= -->
  <main id="main">
    <section id="services" class="services">
      <div class="container">
        <div class="section-title">
          <div class="row">
            <div class="col-md-1 icon-box">
              <button class="icon">
                <a href="../index.html#services"><i class="bi bi-arrow-return-left"></i></a>
              </button>
            </div>
            <div class="col">
              <h2>Área do developer</h2>
            </div>
          </div>
        </div>
      </div>

      <!-- ======= Deployment CI/CD Section ======= -->
      <div class="container">
        <p style="text-align: justify;" data-aos="fade-right">
          Inicialmente, após o processo de levantamento de requisitos e da escolha de uma arquitetura adequada aos
          mesmos, foi necessário proceder à escolha das ferramentas a ser utilizadas.
        </p>
        <p style="text-align: justify;" data-aos="fade-left">
          A nível de backend optou-se por implementar o sistema usando a plataforma Spring Boot, dado que a mesma
          permite criar a base do projeto de forma rápida e eficiente. Relativamente ao frontend, dado que um dos
          requisitos dos sistema passa por uma rápida atualização das componentes visuais do website, o ReactJS surgiu
          como uma opção viável, por permitir atualizar componentes individualmente, de forma rápida, eficiente e leve,
          dado que não são necessários muitos recursos.
        </p>
        <p style="text-align: justify;" data-aos="fade-right">
          Como referido anteriormente, o sistema foi desenvolvido através do uso da plataforma Spring Boot, no
          entanto, ao longo de todo o desenvolvimento do sistema, com o intuito de implementar as suas diversas
          funcionalidades, foram usadas diversas outras ferramentas, entre elas acaba por se destacar, por um lado, o
          Docker, Docker Registry e Jenkins, que auxiliam o processo de automatização e atualização do sistema. Por
          outro lado, o uso da plataforma Kafka permite que os diversos componentes do sistema comuniquem entre si de
          forma rápida, através de mensagens que, no caso do serviço responsável pela parte das estatísticas, acabam
          ainda por ser processadas com recurso a Kafka Streams.
        </p>
        <p style="text-align: justify;" data-aos="fade-right">
          Para além das ferramentas acima enumeradas, existem ainda aquelas cujo uso, apesar de não estar relacionado
          com o runtime, são também de extrema importância. Destacam-se assim, por exemplo, o Logback, Logstash,
          Elasticsearch e Kibana, uma vez que o seu uso permite uma melhor gestão dos logs, facilitando o processo de
          verificação e validação do estado do sistema.
        </p>
        <table class="center" data-aos="fade-right">
          <tr>
            <td style="background-color:rgba(255, 217, 0, 0.856)"><b>Ferramenta</b></td>
            <td style="background-color:rgba(255, 217, 0, 0.856)"><b>Porta</b></td>
          </tr>
          <tr>
            <td><b>Kafka</b></td>
            <td>9092</td>
          </tr>
          <tr>
            <td><b>Zookeeper</b></td>
            <td>2181</td>
          </tr>
          <tr>
            <td><b>React</b></td>
            <td>3001</td>
          </tr>
        </table>
        <p style="text-align: justify; padding-top: 10px;" data-aos="fade-right">
          <font color="#ff0000"> Segundo a atual implementação do sistema, tal como já foi referido, este é composto por
            diversos componentes, alguns deles diretamente relacionados com os microsserviços implementados. Apesar de
            todos eles correrem na mesma máquina, os seus papéis são distintos, dado que a cada um deles estão
            associados diferentes responsabilidades. Um outro aspeto que vale a pena reforçar é o facto de a atual
            arquitetura, baseada em microsserviços, tornar a tarefa de criação de serviços, ou até mesmo a extensão dos
            atuais, bastante simplificada. O atual sistema é composto por cinco microsserviços distintos, que acabam por
            se interligar de forma a satisfazer os requisitos do sistema.
            O microsserviço DatabaseConnector tem como principal objetivo permitir uma ligação entre a OpenSky API, os
            repositórios existentes e o restante sistema. Na verdade, a este serviço está associado um schedule
            (atualmente configurado segundo um intervalo de dez minutos), que tem como objetivo não só guardar a
            informação mais recente fornecida pela API externa, como também enviar essa mesma informação para os
            diferentes tópicos existentes. Os dados presentes nos diversos repositórios podem ser acedidos,
            posteriormente, através da REST API desenvolvida, pelo serviço PlaneJaneAggregator. Este último, tal como o
            nome dá a indicar, tem como objetivo agregar a informação presente nos diversos serviços, a fim de os
            agrupar numa só REST API, a ser usada pelo website, com o intuito de apresentar aos utilizadores não só os
            dados mais recentes como também a informação que pode ser extraída através dos dados inicialmente fornecidos
            pela OpenSky API. Esta extração de informação é obtida após o processamento presente nos dois restantes
            microserviços: RealtimeProcessing e StatisticsProcessor. Em ambos é feito uso de Kafka Streams, com o
            objetivo de processar os dados enviados para os diversos tópicos. O primeiro tem como objetivo analisar os
            dados presentes no tópico esp55_state_vector_velocity e esp55_state_vector_position para calcular a
            velocidade média de cada voo e a sua rota, enquanto que o segundo tem como objetivo analisar os dados
            presentes no tópico esp55_state_vector_routes, com o intuito de apresentar dados estatísticos relativos aos
            diversos voos, nomeadamente as rotas mais comuns.
            Todos os microsserviços acima enumerados têm um ficheiro application.properties a si associado, no qual é
            possível configurar os diversos IP e Ports, o que simplifica o processo de reconfiguração, caso este seja
            necessário.
            Dadas as características do sistema, descritas, por alto, anteriormente, é possível verificar que existem
            ainda outras features a ser desenvolvidas. Dada a arquitetura do sistema, é bastante direto o processo de
            adição de novos componentes, isto é, microsserviços, dado que apenas terá que seguir a lógica até então
            aplicada e garantir que o microsserviço desenvolvido consegue efetivamente comunicar com o restante sistema.
            Um aspeto importante de referir é que, atualmente, não é feita nenhuma gestão dos dados recolhidos a partir
            da API OpenSky, isto é, com o passar do tempo os dados vão deixando de ser relevantes, dado que irão
            referir-se a dados obsoletos, e dado que a quantidade de dados enviados, por pedido, pela API, é ainda
            considerável, é de supor que, com o decorrer do tempo seja necessário mudar o atual esquema de dados, de
            forma a atualizar os dados em função de um determinado ICAO, ou seja, guardando apenas os dados atuais.
            Alternativamente, poder-se-á optar por eliminar os dados com base em timestamps, para evitar a acumulação
            dos mesmos.
            Como já foi mencionado, os dados apresentados no sistema PlaneJane são provenientes da API OpenSky. Para
            poder fazer uma quantidade maior de pedidos é necessário criar uma conta neste serviço. Esta conta terá a si
            associada credenciais, que deverão ser substituídas pelas atuais, de forma a que o sistema continue a ser
            capaz de realizar pedidos.
          </font>
        </p>
        <p style="padding-top: 20px"></p>
      </div>
    </section>
  </main>
  <!-- End #main -->

  <a href="#" class="back-to-top d-flex align-items-center justify-content-center"><i
      class="bi bi-arrow-up-short"></i></a>

  <!-- Vendor JS Files -->
  <script src="../assets/vendor/aos/aos.js"></script>
  <script src="../assets/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  <script src="../assets/vendor/glightbox/js/glightbox.min.js"></script>
  <script src="../assets/vendor/isotope-layout/isotope.pkgd.min.js"></script>
  <script src="../assets/vendor/php-email-form/validate.js"></script>
  <script src="../assets/vendor/purecounter/purecounter.js"></script>
  <script src="../assets/vendor/swiper/swiper-bundle.min.js"></script>
  <script src="../assets/vendor/typed.js/typed.min.js"></script>
  <script src="../assets/vendor/waypoints/noframework.waypoints.js"></script>

  <!-- Template Main JS File -->
  <script src="../assets/js/main.js"></script>

</body>

</html>